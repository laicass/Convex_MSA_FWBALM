/*################################################################ 
## MODULE: MSA_Convex.cpp
## VERSION: 1.0 
## SINCE 2015-09-01
##      
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

#include "MSA_Convex_Local_Pair.h"

/* Debugging option */
// #define RECURSION_TRACE
// #define FIRST_SUBPROBLEM_DEBUG
// #define SECOND_SUBPROBLEM_DEBUG

void usage () { cout << "./MSA_Convex (options) [seq_file]" << endl;
    cout << "seq_file should contain one or more DNA sequence. " << endl;
    cout << "Options: " << endl;
    cout << "\t-l Set the maximum length of model sequence. (default 0)" << endl;
    cout << "\t-m Set step size (\\mu) for updating the ADMM coordinate variables. (default 0.1)"<< endl;
    cout << "\t-p Set maximum pertubation of penalty to break ties. (default 0)"<< endl;
    cout << "\t-s Set ADMM early stop toggle: early stop (on) if > 0. (default on)"<< endl;
    cout << "\t-r Set whether reinitialize W_1 and W_2 at each ADMM iteration. (default off)"<< endl;
}

void parse_cmd_line (int argn, char** argv) {
    if (argn < 2) { 
        usage();
        exit(0);
    }
    int i;
    for(i = 1; i < argn; i++){
        if ( argv[i][0] != '-' ) break;
        if ( ++i >= argn ) usage();
        switch(argv[i-1][1]){
            case 'e': ADMM_EARLY_STOP_TOGGLE = (atoi(argv[i])>0); break;
            case 'r': REINIT_W_ZERO_TOGGLE = (atoi(argv[i])>0); break;
            case 'l': LENGTH_OFFSET = atoi(argv[i]); break;
            case 'm': MU = atof(argv[i]); break;
            case 'p': PERB_EPS = atof(argv[i]); break;
            default:
                      cerr << "unknown option: -" << argv[i-1][1] << endl;
                      usage();
                      exit(0);
        }
    }
    if (i >= argn) usage();
    trainFname = argv[i];
    recFname = argv[i+1];
}

void parse_seqs_file (SequenceSet& allSeqs, int& numSeq, char* fname) {
    ifstream seq_file(fname);
    string tmp_str;
    while (getline(seq_file, tmp_str)) {
        int seq_len = tmp_str.size();
        Sequence ht_tmp_seq (seq_len+1+1, 0);
        ht_tmp_seq[0] = '*';
        for(int i = 0; i < seq_len; i ++) 
            ht_tmp_seq[i+1] = tmp_str.at(i);
        ht_tmp_seq[seq_len+1] = '#';
        allSeqs.push_back(ht_tmp_seq);
        ++ numSeq;
    }
    seq_file.close();
}

void parse_rec_file (Sequence& recSeq, char* fname) {
    ifstream seq_file(fname);
    string tmp_str;
    while (getline(seq_file, tmp_str)) {
        int seq_len = tmp_str.size();
        Sequence ht_tmp_seq (seq_len+1+1, 0);
        for(int i = 0; i < seq_len; i ++) 
            ht_tmp_seq[i+1] = tmp_str.at(i);
        recSeq = ht_tmp_seq;
    }
    seq_file.close();
}

int get_init_model_length (vector<int>& lenSeqs) {
    int max_seq_length = -1;
    int numSeq = lenSeqs.size(); 
    for (int i = 0; i < numSeq; i ++)
        if (lenSeqs[i] > max_seq_length) 
            max_seq_length = lenSeqs[i];
    return max_seq_length;
}


void sequence_dump (SequenceSet& allSeqs, int n) {
    char buffer [50];
    sprintf (buffer, "Seq%5d", n);
    cout << buffer << ": ";
    for (int j = 0; j < allSeqs[n].size(); j ++) 
        cout << allSeqs[n][j];
    cout << endl;
}

int main (int argn, char** argv) {
    // 1. parse cmd 
    parse_cmd_line(argn, argv);
    // 2. input DNA sequence file
    int numSeq = 0;
    SequenceSet allSeqs (0, Sequence());
    parse_seqs_file(allSeqs, numSeq, trainFname);
    Sequence recSeq;
    parse_rec_file(recSeq, recFname);
    vector<int> lenSeqs (numSeq, 0);
    for (int n = 0; n < numSeq; n ++) 
        lenSeqs[n] = allSeqs[n].size();
    int T2 = get_init_model_length (lenSeqs) + LENGTH_OFFSET; // model_seq_length
    
    // NOTE: rounding scheme
    SequenceSet allModelSeqs, allDataSeqs;
    for (int n = 0; n < numSeq; n ++) {
        Sequence model_seq = recSeq, data_seq = allSeqs[n];
        data_seq.erase(data_seq.begin());
        model_seq.erase(model_seq.begin());
        data_seq.erase(data_seq.end()-1);
        model_seq.erase(model_seq.end()-1);

        // align sequences locally
        Plane plane (data_seq.size()+1, Trace(model_seq.size()+1, Cell(2)));
        Trace trace (0, Cell(2));
        smith_waterman (model_seq, data_seq, plane, trace);

        // 4. output the result
        
        model_seq.clear(); data_seq.clear();
        for (int i = 0; i < trace.size(); i ++) 
            model_seq.push_back(trace[i].acidA);
        for (int i = 0; i < trace.size(); i ++) 
            data_seq.push_back(trace[i].acidB);
        allModelSeqs.push_back(model_seq);
        allDataSeqs.push_back(data_seq);
        /*
        for (int i = 0; i < model_seq.size(); i ++) cout << model_seq[i];
        cout << endl;
        for (int i = 0; i < data_seq.size(); i ++) cout << data_seq[i];
        cout << endl;
        */
        
    }
    cout << ">>>>>>>>>>>>>>>>>>>>>ClustalOmegaView<<<<<<<<<<<<<<<<<<<<<<" << endl;
    SequenceSet allCOSeqs (numSeq, Sequence(0));
    vector<int> pos(numSeq, 0);
    while (true) {
        set<int> insertion_ids;
        for (int i = 0; i < numSeq; i ++) {
            if (pos[i] >= allModelSeqs[i].size()) continue;
            if (allModelSeqs[i][pos[i]] == '-') 
                insertion_ids.insert(i);
        }
        if (insertion_ids.size() != 0) {
            // insertion exists
            for (int i = 0; i < numSeq; i ++) {
                if (insertion_ids.find(i)==insertion_ids.end()) // not in set
                    allCOSeqs[i].push_back('-');
                else { // in set
                    allCOSeqs[i].push_back(allDataSeqs[i][pos[i]++]);
                }
            }
        } else { // no insertion
            for (int i = 0; i < numSeq; i ++) 
                allCOSeqs[i].push_back(allDataSeqs[i][pos[i]++]);
        }
        // terminating
        bool terminated = true;
        for (int i = 0; i < numSeq; i ++) 
            if (pos[i] != allModelSeqs[i].size()) {
                terminated = false; 
                break;
            }
        if (terminated) break;
    }
    time_t end = time(NULL);
    string fname (trainFname);
    fname = fname + ".co";
    ofstream co_out (fname.c_str());
    for (int i = 0; i < numSeq; i ++) {
        for (int j = 0; j < allCOSeqs[i].size(); j++)  {
            co_out << allCOSeqs[i][j];
            cout << allCOSeqs[i][j];
        }
        co_out << endl;
        cout << endl;
    }
    co_out.close();
    return 0;
}
